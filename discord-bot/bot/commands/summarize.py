"""
Summarize Command - Generate AI-powered trading summaries from stored signals
"""

import discord
from discord import app_commands
from discord.ext import commands
from datetime import datetime, timedelta
import logging
from typing import Optional

from ..services.signal_storage import get_storage

logger = logging.getLogger(__name__)


async def setup(bot):
    """Setup summarize commands"""
    await bot.add_cog(SummarizeCommands(bot))


class SummarizeCommands(commands.Cog):
    """Commands for summarizing stored trading signals"""
    
    def __init__(self, bot):
        self.bot = bot
    
    @app_commands.command(
        name="summarize",
        description="Get AI-powered trading summary for a stock"
    )
    @app_commands.describe(
        symbol="Stock symbol (e.g., AAPL, TSLA)",
        days="Number of days to look back (1-5, default: 1)"
    )
    async def summarize(self, interaction: discord.Interaction, symbol: str, days: Optional[int] = 1):
        """Generate trading summary from stored signals"""
        await interaction.response.defer()
        
        try:
            # Validate days
            if days < 1 or days > 5:
                await interaction.followup.send("‚ùå Days must be between 1 and 5")
                return
            
            symbol = symbol.upper()
            
            # Get storage and summary
            storage = get_storage()
            summary = storage.get_summary(symbol, days=days)
            
            if summary['total_signals'] == 0:
                period_text = "today" if days == 1 else f"the last {days} days"
                await interaction.followup.send(
                    f"üì≠ No signals found for **{symbol}** {period_text}.\n"
                    f"Signals are generated by whale flow, zscore scanner, TOS alerts, and ETF momentum scanners."
                )
                return
            
            # Create and send embed
            embed = format_summary_embed(symbol, summary, days)
            await interaction.followup.send(embed=embed)
            
            logger.info(f"Generated summary for {symbol} ({days} days) - {summary['total_signals']} signals")
            
        except Exception as e:
            logger.error(f"Error generating summary: {e}", exc_info=True)
            await interaction.followup.send(f"‚ùå Error generating summary: {str(e)}")
    
    
    @app_commands.command(
        name="timeline",
        description="Show chronological timeline of all activity for a stock"
    )
    @app_commands.describe(
        symbol="Stock symbol (e.g., AAPL, TSLA)",
        days="Number of days to look back (1-5, default: 5)"
    )
    async def timeline(self, interaction: discord.Interaction, symbol: str, days: Optional[int] = 5):
        """Show day-by-day timeline of signals"""
        await interaction.response.defer()
        
        try:
            # Validate days
            if days < 1 or days > 5:
                await interaction.followup.send("‚ùå Days must be between 1 and 5")
                return
            
            symbol = symbol.upper()
            
            # Get timeline
            storage = get_storage()
            timeline = storage.get_stock_activity_timeline(symbol, days=days)
            
            if not timeline:
                await interaction.followup.send(
                    f"üì≠ No activity found for **{symbol}** in the last {days} days."
                )
                return
            
            # Create embed
            embed = discord.Embed(
                title=f"üìÖ {symbol} Activity Timeline",
                description=f"Last {days} days of trading signals",
                color=discord.Color.blue(),
                timestamp=datetime.now()
            )
            
            # Add each day
            for day_data in timeline[:5]:  # Max 5 days
                date = day_data['date']
                signals = day_data['signals']
                
                signal_lines = []
                for signal in signals[:5]:  # Max 5 signals per day
                    sig_type = signal['signal_type']
                    subtype = signal.get('signal_subtype', '')
                    
                    emoji = {
                        'WHALE': 'üêã',
                        'ZSCORE': 'üìä',
                        'TOS': 'üéØ',
                        'ETF_MOMENTUM': 'üìà'
                    }.get(sig_type, 'üìç')
                    
                    time = signal['timestamp'].split(' ')[1].split(':')
                    time_str = f"{time[0]}:{time[1]}"
                    
                    line = f"{emoji} `{time_str}` {sig_type}"
                    if subtype:
                        line += f" - {subtype}"
                    
                    signal_lines.append(line)
                
                if len(signals) > 5:
                    signal_lines.append(f"... and {len(signals) - 5} more")
                
                embed.add_field(
                    name=f"üìÜ {date} ({len(signals)} signals)",
                    value='\n'.join(signal_lines) if signal_lines else "No signals",
                    inline=False
                )
            
            await interaction.followup.send(embed=embed)
            logger.info(f"Generated timeline for {symbol} ({days} days)")
            
        except Exception as e:
            logger.error(f"Error generating timeline: {e}", exc_info=True)
            await interaction.followup.send(f"‚ùå Error generating timeline: {str(e)}")



def format_summary_embed(symbol: str, summary: dict, days: int) -> discord.Embed:
    """Create rich embed with trading summary"""
    
    # Determine overall sentiment
    bullish = summary['by_direction']['BULLISH']
    bearish = summary['by_direction']['BEARISH']
    neutral = summary['by_direction']['NEUTRAL']
    
    if bullish > bearish:
        color = discord.Color.green()
        sentiment = "üêÇ BULLISH"
    elif bearish > bullish:
        color = discord.Color.red()
        sentiment = "üêª BEARISH"
    else:
        color = discord.Color.gold()
        sentiment = "‚öñÔ∏è NEUTRAL"
    
    # Create embed
    period_text = "Today" if days == 1 else f"Last {days} Days"
    embed = discord.Embed(
        title=f"üìä {symbol} Trading Summary - {period_text}",
        description=f"**Overall Sentiment:** {sentiment}",
        color=color,
        timestamp=datetime.now()
    )
    
    # Price movement
    if summary['price_range']['current'] and summary['price_range']['high'] and summary['price_range']['low']:
        current = summary['price_range']['current']
        high = summary['price_range']['high']
        low = summary['price_range']['low']
        range_pct = ((high - low) / low) * 100 if low > 0 else 0
        
        embed.add_field(
            name="üí∞ Price Action",
            value=f"Current: **${current:.2f}**\n"
                  f"Range: ${low:.2f} - ${high:.2f} ({range_pct:.1f}%)",
            inline=False
        )
    
    # Signal counts by type
    if summary['by_type']:
        signal_summary = []
        
        # Whale Flow
        if 'WHALE' in summary['by_type']:
            whale_data = summary['by_type']['WHALE']
            whale_text = f"üêã **Whale Flow**: {whale_data['count']} signals"
            if whale_data['subtypes']:
                subtypes = [f"{k}({v})" for k, v in whale_data['subtypes'].items()]
                whale_text += f"\n   ‚îî {', '.join(subtypes)}"
            signal_summary.append(whale_text)
        
        # Z-Score
        if 'ZSCORE' in summary['by_type']:
            zscore_data = summary['by_type']['ZSCORE']
            zscore_text = f"üìä **Z-Score**: {zscore_data['count']} signals"
            if zscore_data['subtypes']:
                subtypes = [f"{k}({v})" for k, v in zscore_data['subtypes'].items()]
                zscore_text += f"\n   ‚îî {', '.join(subtypes)}"
            signal_summary.append(zscore_text)
        
        # TOS Alerts
        if 'TOS' in summary['by_type']:
            tos_data = summary['by_type']['TOS']
            tos_text = f"üéØ **TOS Alerts**: {tos_data['count']} signals"
            if tos_data['subtypes']:
                subtypes = [f"{k}({v})" for k, v in tos_data['subtypes'].items()]
                tos_text += f"\n   ‚îî {', '.join(subtypes)}"
            signal_summary.append(tos_text)
        
        # ETF Momentum
        if 'ETF_MOMENTUM' in summary['by_type']:
            etf_data = summary['by_type']['ETF_MOMENTUM']
            etf_text = f"üìà **ETF Momentum**: {etf_data['count']} signals"
            if etf_data['subtypes']:
                subtypes = [f"{k}({v})" for k, v in etf_data['subtypes'].items()]
                etf_text += f"\n   ‚îî {', '.join(subtypes)}"
            signal_summary.append(etf_text)
        
        if signal_summary:
            embed.add_field(
                name="üì° Signal Breakdown",
                value='\n\n'.join(signal_summary),
                inline=False
            )
    
    # Recent activity (last 3 signals)
    if summary['latest_signals']:
        recent_text = []
        for signal in summary['latest_signals'][:3]:
            timestamp = signal['timestamp']
            sig_type = signal['signal_type']
            subtype = signal.get('signal_subtype', '')
            direction = signal.get('direction', '')
            
            # Format timestamp
            try:
                dt = datetime.fromisoformat(timestamp)
                time_str = dt.strftime('%I:%M %p')
            except:
                time_str = timestamp.split(' ')[1] if ' ' in timestamp else timestamp
            
            # Emoji based on type
            emoji = {
                'WHALE': 'üêã',
                'ZSCORE': 'üìä',
                'TOS': 'üéØ',
                'ETF_MOMENTUM': 'üìà'
            }.get(sig_type, 'üìç')
            
            line = f"{emoji} `{time_str}` {sig_type}"
            if subtype:
                line += f" - **{subtype}**"
            if direction:
                dir_emoji = {'BULLISH': 'üü¢', 'BEARISH': 'üî¥', 'NEUTRAL': '‚ö™'}.get(direction, '')
                line += f" {dir_emoji}"
            
            recent_text.append(line)
        
        embed.add_field(
            name="üïê Recent Activity",
            value='\n'.join(recent_text),
            inline=False
        )
    
    # Generate AI insights
    insights = generate_insights(symbol, summary, days)
    if insights:
        embed.add_field(
            name="üí° Key Insights",
            value=insights,
            inline=False
        )
    
    embed.set_footer(text=f"Total Signals: {summary['total_signals']} | {bullish}üü¢ {bearish}üî¥ {neutral}‚ö™")
    
    return embed


def generate_insights(symbol: str, summary: dict, days: int) -> str:
    """Generate human-readable insights from summary data"""
    insights = []
    
    # Whale activity
    if 'WHALE' in summary['by_type']:
        whale_count = summary['by_type']['WHALE']['count']
        if whale_count >= 3:
            insights.append(f"üêã **Heavy whale activity** ({whale_count} large trades detected)")
        
        subtypes = summary['by_type']['WHALE'].get('subtypes', {})
        if 'BUY' in subtypes and subtypes['BUY'] > subtypes.get('SELL', 0):
            insights.append("üí™ Whales are accumulating - strong buying pressure")
        elif 'SELL' in subtypes and subtypes['SELL'] > subtypes.get('BUY', 0):
            insights.append("‚ö†Ô∏è Whales are distributing - selling pressure detected")
    
    # Z-Score analysis
    if 'ZSCORE' in summary['by_type']:
        subtypes = summary['by_type']['ZSCORE'].get('subtypes', {})
        
        if 'OVERBOUGHT' in subtypes:
            insights.append(f"üìä Entered overbought zone - potential pullback ahead")
        elif 'OVERSOLD' in subtypes:
            insights.append(f"üìä Hit oversold levels - bounce opportunity")
        
        if 'RECOVERY' in subtypes:
            insights.append(f"üí´ Recovery momentum detected - bouncing from lows")
        
        # Check for reversals
        if 'SELL_SIGNAL' in subtypes and 'OVERBOUGHT' in subtypes:
            insights.append(f"üî¥ Reversal signal: Crossed down from overbought")
        elif 'BUY_SIGNAL' in subtypes and 'OVERSOLD' in subtypes:
            insights.append(f"üü¢ Reversal signal: Crossed up from oversold")
    
    # TOS Alerts
    if 'TOS' in summary['by_type']:
        tos_count = summary['by_type']['TOS']['count']
        subtypes = summary['by_type']['TOS'].get('subtypes', {})
        
        if tos_count >= 2:
            if 'BULLISH' in subtypes or 'BUY' in subtypes:
                insights.append(f"üéØ Multiple bullish TOS setups forming")
            elif 'BEARISH' in subtypes or 'SELL' in subtypes:
                insights.append(f"üéØ Multiple bearish TOS setups forming")
    
    # ETF Momentum
    if 'ETF_MOMENTUM' in summary['by_type']:
        subtypes = summary['by_type']['ETF_MOMENTUM'].get('subtypes', {})
        
        if 'STRONG_MOMENTUM' in subtypes:
            insights.append(f"üöÄ Strong momentum trend in play")
        elif 'MOMENTUM_SHIFT' in subtypes:
            insights.append(f"üîÑ Momentum shift detected - trend change possible")
    
    # Overall pattern analysis
    if summary['total_signals'] >= 5:
        if summary['by_direction']['BULLISH'] >= summary['total_signals'] * 0.7:
            insights.append(f"üéØ **Consistent bullish signals** - strong uptrend")
        elif summary['by_direction']['BEARISH'] >= summary['total_signals'] * 0.7:
            insights.append(f"üéØ **Consistent bearish signals** - strong downtrend")
        elif summary['by_direction']['NEUTRAL'] >= summary['total_signals'] * 0.6:
            insights.append(f"‚öñÔ∏è Sideways action - waiting for directional move")
    
    # Activity level
    if days > 1:
        avg_signals_per_day = summary['total_signals'] / days
        if avg_signals_per_day >= 3:
            insights.append(f"‚ö° High activity stock - {avg_signals_per_day:.1f} signals/day")
        elif summary['total_signals'] <= 2:
            insights.append(f"üìâ Low activity - limited signal generation")
    
    if not insights:
        insights.append("üìä Continue monitoring for new signals")
    
    return '\n'.join(f"‚Ä¢ {insight}" for insight in insights)
